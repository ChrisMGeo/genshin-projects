import type { PlopTypes } from "@turbo/gen";
import { existsSync, readdirSync, readFileSync, writeFileSync } from "fs";
import path from "path";
import JsonToTS from "json-to-ts";

const REPO_ROOT = path.resolve(".", "packages", "gi-data");

const GI_DM_ROOT = path.join(REPO_ROOT, "AnimeGameData");

const EBO = path.join(GI_DM_ROOT, "ExcelBinOutput");

const getEBOFilePath = (fileName: string) => path.join(EBO, fileName);

const getEBOFileContent = (fileName: string) => {
  const filePath = getEBOFilePath(fileName);
  if (!existsSync(filePath)) throw `File not found :${filePath}`;
  return readFileSync(filePath).toString();
};

const getParsedEBOFile = (fileName: string) => {
  return JSON.parse(getEBOFileContent(fileName));
};

// Learn more about Turborepo Generators at https://turbo.build/repo/docs/core-concepts/monorepos/code-generation

const generateGIDataTypes: PlopTypes.CustomActionFunction = async (answers) => {
  const { pascalCaseToKebabCase } = await import("@repo/utils/pascal-to-kebab");
  let EBOJsonFiles: string[] = [];
  try {
    EBOJsonFiles = readdirSync(EBO).filter((f) => path.extname(f) === ".json");
  } catch (error) {
    console.error(error);
  }
  for (const jsonFileName of EBOJsonFiles) {
    const strippedFileName = path.parse(jsonFileName).name;
    const typeName = strippedFileName.endsWith("ExcelConfigData")
      ? strippedFileName.slice(0, -"ExcelConfigData".length)
      : strippedFileName;
    let content: string = "";
    try {
      content = getEBOFileContent(jsonFileName);
    } catch (error) {
      console.error(error);
    }
    const jsonContent = JSON.parse(content);
    const isArray = Array.isArray(jsonContent);
    let lines: string[] = [];
    try {
      lines = JsonToTS(jsonContent, {
        useTypeAlias: true,
      });
    } catch (error) {
      console.error(error);
    }
    const typeFileLines = [
      `// generated by gi-data-types for \`${jsonFileName}\``,
      `import { readDMJSON } from "../../util.js";`,
      lines.join("\n"),
      `export default JSON.parse(readDMJSON("ExcelBinOutput/${JSON.stringify(jsonFileName).slice(1, -1)}"))${lines.length === 0 ? "" : ` as RootObject${isArray ? "[]" : ""}`}`,
    ];
    const typeFileContent = typeFileLines.join("\n");
    const typeFileLocation = path.join(
      REPO_ROOT,
      "src",
      "generated",
      "excel-bin-output",
      `${pascalCaseToKebabCase(typeName)}.ts`
    );
    writeFileSync(typeFileLocation, typeFileContent);
    console.log(`Write to "${typeFileLocation} was successful..."`);
  }

  return "Finished generating types!";
};

const removeIrrelevant: PlopTypes.CustomActionFunction = async (answers) => {
  return "Removed irrelevant types!";
};

const findTextMapReference: PlopTypes.CustomActionFunction = async (
  _answers
) => {
  const answers = _answers as { in: string };
  return `Found references to ${JSON.stringify(answers.in)}!`;
};

export default function generator(plop: PlopTypes.NodePlopAPI): void {
  plop.setGenerator("gi-data-types", {
    description: "Generates types for `AnimeGameData/ExcelBinOutput/*.json`",
    prompts: [],
    actions: [generateGIDataTypes],
  });

  plop.setGenerator("remove-unused-gi-data-types", {
    description: "Removes unused types from `packages/gi-data/src/generated/`",
    prompts: [],
    actions: [removeIrrelevant],
  });

  plop.setGenerator("find-textmap-references", {
    description: "Helper action to find instances of a string",
    prompts: [
      {
        type: "input",
        name: "in",
        message: "What is the string you are searching for?",
      },
    ],
    actions: [findTextMapReference],
  });
}
